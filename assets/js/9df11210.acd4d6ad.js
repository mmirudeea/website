"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6501],{28228:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"lab/04/index","title":"04 - Asynchronous Development","description":"Asynchronous Programming with Embassy","source":"@site/versioned_docs/version-acs_cc/lab/04/index.md","sourceDirName":"lab/04","slug":"/lab/04","permalink":"/docs/acs_cc/lab/04","draft":false,"unlisted":false,"editUrl":"https://www.github.com/upb-pmrust/website/edit/main/website/lab/04/index.md","tags":[],"version":"acs_cc","frontMatter":{"description":"Asynchronous Programming with Embassy","slug":"/lab/04"},"sidebar":"tutorialSidebar","previous":{"title":"03 - PWM & ADC","permalink":"/docs/acs_cc/lab/03"},"next":{"title":"05 - Serial Peripheral Interface","permalink":"/docs/acs_cc/lab/05"}}');var i=t(74848),r=t(28453);const a={description:"Asynchronous Programming with Embassy",slug:"/lab/04"},o="04 - Asynchronous Development",l={},c=[{value:"Resources",id:"resources",level:2},{value:"Asynchronous functions and Tasks",id:"asynchronous-functions-and-tasks",level:2},{value:"<code>await</code> keyword",id:"await-keyword",level:2},{value:"<code>Future</code>s",id:"futures",level:2},{value:"<code>await</code>ing multiple <code>Future</code>s",id:"awaiting-multiple-futures",level:3},{value:"<code>select</code>",id:"select",level:4},{value:"<code>join</code>",id:"join",level:4},{value:"Channel",id:"channel",level:2},{value:"<code>Signal</code>",id:"signal",level:3},{value:"<code>PubSubChannel</code>",id:"pubsubchannel",level:3},{value:"Buzzer",id:"buzzer",level:2},{value:"How to wire an RGB LED",id:"how-to-wire-an-rgb-led",level:4},{value:"Exercises",id:"exercises",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"04---asynchronous-development",children:"04 - Asynchronous Development"})}),"\n",(0,i.jsx)(n.p,{children:"This lab will teach you the principles of asynchronous programming, and its application in Embassy."}),"\n",(0,i.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bert Peters"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.a,{href:"https://bertptrs.nl/2023/04/27/how-does-async-rust-work.html",children:"How does async Rust work"})})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Omar Hiari"}),", ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.a,{href:"https://dev.to/apollolabsbin/sharing-data-among-tasks-in-rust-embassy-synchronization-primitives-59hk",children:"Sharing Data Among Tasks in Rust Embassy: Synchronization Primitives"})})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"asynchronous-functions-and-tasks",children:"Asynchronous functions and Tasks"}),"\n",(0,i.jsx)(n.p,{children:"Until now you've only worked with simple (almost) serial programs. However, not all programs can be designed to run serially/sequentially. Handling multiple I/O events concurrently usually requires separate parallel tasks.\nExample: Reading a button press while blinking an LED. A single loop would block the button reading event while waiting for the timer to finish."}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Button as Button\n    participant Timer as Timer\n    participant Task as Main Task (LED + Button)\n    participant LED as LED Control\n    \n    loop\n    %% LED starts blinking\n    Task->>LED: Turn LED ON\n    Timer->>+Task: Delay 1 sec (Blocks everything)\n    \n    %% Button presses button during delay\n    Button--\x3e>Task: Button Press Sent (but microcontroller is busy)\n \n    \n    Task->>-Task: Continue with next instruction\n    %% LED continues\n    Task->>LED: Turn LED OFF\n\n    Timer->>+Task: Delay 1 sec (Blocks everything)\n    Button--\x3e>Task:Button Press Sent (but microcontroller is busy)\n\n    Task->>-Task: Continue with next instruction\n\n    %% Now the task checks the button, but it's too late\n\n    Task->>Button: Check if button is pressed\n    Button--\x3e>Task: No press detected (press was missed)\n    end\n    \n    Note over Button, Button: User pressed button, but MCU was busy!\n    Note over Task: Button check happens too late.\n\n"}),"\n",(0,i.jsxs)(n.p,{children:["To address this issue, we would need to spawn a new task in which we would wait for the button press, while blinking the LED in the ",(0,i.jsx)(n.code,{children:"main"})," function."]}),"\n",(0,i.jsxs)(n.p,{children:["When thinking of how exactly this works, you would probably think that the task is running on a separate ",(0,i.jsx)(n.em,{children:"thread"})," than the ",(0,i.jsx)(n.code,{children:"main"})," function. Usually this would be the case when developing a normal computer application. Multithreading is possible, but requires a preemptive operating system. Without one, only one thread can independently run per processor core and that means that, since we are using only one core of the RP2350 (which actually has only 2), we would only be able to run ",(0,i.jsx)(n.strong,{children:"one thread at a time"}),". So how exactly does the task wait for the button press in parallel with the LED blinking?\nShort answer is: it doesn't. In reality, both functions run asynchronously."]}),"\n",(0,i.jsxs)(n.p,{children:["A task in Embassy is represented by an ",(0,i.jsx)(n.em,{children:"asynchronous function"}),". Asynchronous functions are different from normal functions, in the sense that they allow asynchronous code execution. Let's take an example from the previous lab:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[embassy_executor::task]\nasync fn button_pressed(mut led: Output<'static>, mut button: Input<'static>) {\n    loop {\n\tinfo!(\"waiting for button press\");\n        button.wait_for_falling_edge().await;\n        led.toggle();\n    }\n}\n\n#[embassy_executor::main]\nasync fn main(spawner: Spawner) {\n    let peripherals = embassy_rp::init(Default::default());\n\n    let button = Input::new(peripherals.PIN_X, Pull::None);\n    let led2 = Output::new(peripherals.PIN_X, Level::Low);\n\n    spawner.spawn(button_pressed(led2, button)).unwrap();\n\n    let mut led = Output::new(peripherals.PIN_X, Level::Low);\n\n    loop {\n        led.toggle();\n        Timer::after_millis(200).await;\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, we notice that both the ",(0,i.jsx)(n.code,{children:"button_pressed"})," and ",(0,i.jsx)(n.code,{children:"main"})," functions are declared as ",(0,i.jsx)(n.code,{children:"async"}),", telling the compiler to treat them as asynchronous functions. Inside the ",(0,i.jsx)(n.code,{children:"main"})," function (which is also a task, actually), we blink the LED:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"loop {\n    led.toggle();\n\n    Timer::after_millis(200).await;\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"await-keyword",children:[(0,i.jsx)(n.code,{children:"await"})," keyword"]}),"\n",(0,i.jsxs)(n.p,{children:["After setting the timer, our ",(0,i.jsx)(n.code,{children:"main"})," function would need to wait until the alarm fires after 200 ms. Instead of just waiting and blocking the current and ",(0,i.jsx)(n.em,{children:"only"})," thread of execution, it could allow the thread to do another action in the meantime. This is where the ",(0,i.jsx)(n.code,{children:".await"})," keyword comes into play.\nWhen using ",(0,i.jsx)(n.code,{children:".await"})," inside of an asynchronous function, we are telling a third party (called the ",(0,i.jsx)(n.strong,{children:"executor"}),", detailed later) that this action might take more time to finish, so ",(0,i.jsx)(n.em,{children:"do something else"})," until it's ready. Basically, the execution flow of the asynchronous function function is halted exactly where ",(0,i.jsx)(n.code,{children:".await"})," is used, and the executor starts running another task. In our case, it would halt the main function while waiting for the alarm to go off and it could start running the code inside the ",(0,i.jsx)(n.code,{children:"button_pressed"})," task."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'loop {\n    info!("waiting for button press");\n    button.wait_for_falling_edge().await;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We can see that here, we also use the ",(0,i.jsx)(n.code,{children:"wait_for_falling_edge"})," function asynchronously, meaning that until we get a signal that a button has been pressed, the executor can decide to do other stuff. If it has nothing else to do, it goes to sleep, until it receives a signal that either the button has been pressed, or the timer has run out. Then, it will resume execution of the function where the action has completed.\nWhen the button is pressed the execution flow will resume inside of the ",(0,i.jsx)(n.code,{children:"button_pressed"})," task, until it is interrupted by the next ",(0,i.jsx)(n.code,{children:".await"})," in that function. If the timer runs out before the ",(0,i.jsx)(n.code,{children:"button_pressed"})," task execution reaches the next ",(0,i.jsx)(n.code,{children:".await"}),", the resuming of the ",(0,i.jsx)(n.code,{children:"main"})," function will be delayed until the ",(0,i.jsx)(n.code,{children:"button_pressed"})," task ",(0,i.jsx)(n.code,{children:".await"}),'s.\nThis method of development allows our programs to run seemingly "in parallel", without the need of multiple threads. Each task ',(0,i.jsx)(n.em,{children:"voluntarily"})," pauses its execution and passes control over to whatever other task needs it. This means that it's the task's business to allow other tasks to run while it's idly waiting for something to happen on its end."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"On a preemptive operating system, it would be the scheduler's job to decide when and for how long processes get to run."})}),"\n",(0,i.jsxs)(n.h2,{id:"futures",children:[(0,i.jsx)(n.code,{children:"Future"}),"s"]}),"\n",(0,i.jsxs)(n.p,{children:["Rust has a special datatype that represents an action that will complete sometime in the future. By using ",(0,i.jsx)(n.code,{children:".await"})," on a ",(0,i.jsx)(n.code,{children:"Future"}),", we are passing control to another task until the ",(0,i.jsx)(n.code,{children:"Future"})," completes."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["In the ",(0,i.jsx)(n.code,{children:"button_pressed"})," task, the ",(0,i.jsx)(n.code,{children:"wait_for_falling_edge"})," returns a ",(0,i.jsx)(n.code,{children:"Future"}),", which is then ",(0,i.jsx)(n.code,{children:".await"}),"ed."]})}),"\n",(0,i.jsxs)(n.p,{children:["This is a simplified version of what a ",(0,i.jsx)(n.code,{children:"Future"})," in Rust really looks like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"enum Poll<T> {\n    Pending,\n    Ready(T),\n}\n\ntrait Future {\n   type Output;\n   fn poll(&mut self) -> Poll<Self::Output>;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Future"})," has an ",(0,i.jsx)(n.code,{children:"Output"})," associated type, that represents the type of the result that it will return once it completes. For ",(0,i.jsx)(n.code,{children:"wait_for_falling_edge()"}),", the Output type is ",(0,i.jsx)(n.code,{children:"()"})," (nothing).\nThe function ",(0,i.jsx)(n.code,{children:"poll"})," returns a ",(0,i.jsx)(n.code,{children:"Poll"})," type, which can either be ",(0,i.jsx)(n.code,{children:"Pending"}),", or ",(0,i.jsx)(n.code,{children:"Ready<T>"})," (T will be output in this case).\nLet's break down what all of this means. A ",(0,i.jsx)(n.code,{children:"Future"})," needs to be checked on, every now and then, to see what its status is. This is the job of the ",(0,i.jsx)(n.strong,{children:"Executor"}),". The executor must regularly ask the ",(0,i.jsx)(n.code,{children:"Future"})," if it's completed, or if it needs more time before it can give a result. We can say that the ",(0,i.jsx)(n.code,{children:"Future"})," is ",(0,i.jsx)(n.code,{children:"poll"}),"ed, and depending on whether it's ready to give a result or not, it gives its status as ",(0,i.jsx)(n.code,{children:"Pending"})," or ",(0,i.jsx)(n.code,{children:"Ready"}),". If it's still pending, it needs more time before it can return a result, so the executor moves on to poll another ",(0,i.jsx)(n.code,{children:"Future"}),". Whenever the ",(0,i.jsx)(n.code,{children:"Future"})," is completed, it returns ",(0,i.jsx)(n.code,{children:"Ready"})," once polled, and the executor returns execution back to the function where the ",(0,i.jsx)(n.code,{children:"Future"})," ",(0,i.jsx)(n.code,{children:".await"}),"ed."]}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    autonumber\n    Executor->>+Future: poll()\n    loop until the Future finishes all the requests to the Hardware\n        Future->>+Hardware: execute_next_action()\n        Hardware--\x3e>Future: in_progress()\n        note right of Hardware: performs the action in parallel\n        Future--\x3e>-Executor: Poll::Pending\n        note over Executor: sleeps until an event arrives\n        note right of Hardware: sends an event when job is done (interrupt)\n        Hardware--)-Executor: event\n        Executor->>+Future: poll()\n    end\n    Future->>Hardware: read_value()\n    Hardware--\x3e>Future: value\n    Future--\x3e>-Executor: Poll::Ready(value)"}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["An efficient executor will not poll all tasks. Instead, tasks signal the executor that they are ready to make progress by using a ",(0,i.jsx)(n.code,{children:"Waker"}),"."]})}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"A real future in Rust looks like this:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub trait Future {\n    type Output;\n\n    // Required method\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n"})})]}),"\n",(0,i.jsxs)(n.p,{children:["Under the hood, the Rust compiler is actually transforming our asynchronous function into a state-machine. That is why we can only use ",(0,i.jsx)(n.code,{children:".await"})," inside of an ",(0,i.jsx)(n.code,{children:"async"})," function, because it needs to be treated differently than an ordinary function in order to work asynchronously."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Asynchronous programming is widely used in web development. In JavaScript, the equivalent of a ",(0,i.jsx)(n.code,{children:"Future"})," would be a ",(0,i.jsx)(n.code,{children:"Promise"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["Read more about how async/await works in Rust ",(0,i.jsx)(n.a,{href:"https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html",children:"here"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"awaiting-multiple-futures",children:[(0,i.jsx)(n.code,{children:"await"}),"ing multiple ",(0,i.jsx)(n.code,{children:"Future"}),"s"]}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes we need to ",(0,i.jsx)(n.code,{children:".await"})," several futures at the same time. Embassy provides two ways of doing this:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"select"})," - wait for several ",(0,i.jsx)(n.code,{children:"Future"}),"s, stop as soon as ",(0,i.jsx)(n.strong,{children:"one"})," of them ",(0,i.jsx)(n.strong,{children:"returns"}),";"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"join"})," - wait for several ",(0,i.jsx)(n.code,{children:"Future"}),"s until they ",(0,i.jsx)(n.strong,{children:"all return"})]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"select",children:(0,i.jsx)(n.code,{children:"select"})}),"\n",(0,i.jsxs)(n.p,{children:["In some cases, we might find ourselves in the situation where we need to await multiple futures at a time. For example, we want to wait for a button press ",(0,i.jsx)(n.em,{children:"and"})," wait for a timer to expire, and we deal with each future completion in different ways."]}),"\n",(0,i.jsxs)(n.p,{children:["There is a function in Embassy that allows us to do this: ",(0,i.jsx)(n.code,{children:"select"}),". It takes two ",(0,i.jsx)(n.code,{children:"Future"}),"s as arguments, and polls both of them to see which one completes first."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let select = select(button.wait_for_falling_edge(), Timer::after_secs(5)).await;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It returns an ",(0,i.jsx)(n.code,{children:"Either"})," type, that looks like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"pub enum Either<A, B> {\n    First(A),\n    Second(B),\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A and B are the results of each ",(0,i.jsx)(n.code,{children:"Future"}),", so we can just use a ",(0,i.jsx)(n.code,{children:"match"})," on the ",(0,i.jsx)(n.code,{children:"select"})," variable to see which ",(0,i.jsx)(n.code,{children:"Future"})," finished first."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"match select {\n    First(res1) => {\n        // handle case for button press\n    },\n    Second(res2) => {\n        // handle case for alarm firing\n    }\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["After selecting the first ",(0,i.jsx)(n.code,{children:"Future"})," that completes, the other one is ",(0,i.jsx)(n.em,{children:"dropped"}),". For instance, if the button press happens first, the timer will be stopped."]})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["You can also use ",(0,i.jsx)(n.a,{href:"https://docs.rs/embassy-futures/latest/embassy_futures/select/fn.select3.html",children:(0,i.jsx)(n.code,{children:"select3"})}),", ",(0,i.jsx)(n.a,{href:"https://docs.rs/embassy-futures/latest/embassy_futures/select/fn.select4.html",children:(0,i.jsx)(n.code,{children:"select4"})})," or ",(0,i.jsx)(n.a,{href:"https://docs.rs/embassy-futures/latest/embassy_futures/select/fn.select_array.html",children:(0,i.jsx)(n.code,{children:"select_array"})})," when dealing with more than two ",(0,i.jsx)(n.code,{children:"Future"}),"s."]})}),"\n",(0,i.jsx)(n.h4,{id:"join",children:(0,i.jsx)(n.code,{children:"join"})}),"\n",(0,i.jsxs)(n.p,{children:["Similarly, we can also ",(0,i.jsx)(n.a,{href:"https://docs.rs/embassy-futures/latest/embassy_futures/join/fn.join.html",children:(0,i.jsx)(n.code,{children:"join"})})," multiple ",(0,i.jsx)(n.code,{children:"Future"}),"s, meaning that we wait for all of them to complete before moving on."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let (res1, res2) = join(button.wait_for_falling_edge(), Timer::after_secs(5)).await;\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"join"})," returns a tuple containing the results of both ",(0,i.jsx)(n.code,{children:"Future"}),"s."]}),"\n",(0,i.jsx)(n.h2,{id:"channel",children:"Channel"}),"\n",(0,i.jsxs)(n.p,{children:["Up to this point, to be able to share peripherals or data across multiple tasks, we have been using global ",(0,i.jsx)(n.code,{children:"Mutex"}),"s or passing them directly as parameters to the tasks. But there are other, more convenient ways to send data to and from tasks. Instead of having to make global, static variables that are shared by tasks, we could choose to only send the information that we need from one task to another. To achieve this, we can use ",(0,i.jsx)(n.em,{children:"channels"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Channels"})," allow a unidirectional flow of information between two endpoints: the ",(0,i.jsx)(n.em,{children:"Sender"})," and the ",(0,i.jsx)(n.em,{children:"Receiver"}),". The sender sends a value through the channel, and the receiver receives this value once it is ready to do so. Until it is ready, the data will be stored inside a queue. Channels in Embassy are ",(0,i.jsx)(n.em,{children:"Multiple Producer, Multiple Consumer"}),", which means that we can have a channel associated with multiple senders and multiple receivers."]}),"\n",(0,i.jsx)(n.p,{children:"To use a channel in Embassy, we first need to declare a static instance of the channel."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"static CHANNEL: Channel<ThreadModeRawMutex, bool, 64> = Channel::new();\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ThreadModeRawMutex"})," - the type of Mutex that the Channel internally uses. It is a mutex that can safely be shared between threads"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"bool"})," - the type of data that is sent through the channel"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"64"})," - the maximum number of values that can be stored in the channel's queue"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Let's say we spawn a task ",(0,i.jsx)(n.code,{children:"task1"})," that runs a timer. Every second, we want to toggle an LED in the ",(0,i.jsx)(n.code,{children:"main"})," function, based on the timer running in ",(0,i.jsx)(n.code,{children:"task1"}),". For this, ",(0,i.jsx)(n.code,{children:"task1"})," would need to send a signal to the ",(0,i.jsx)(n.code,{children:"main"})," program every time the 1 second alarm has fired, meaning the task and the main program would share the channel. ",(0,i.jsx)(n.code,{children:"task1"})," would ",(0,i.jsx)(n.em,{children:"send"})," over the channel, and ",(0,i.jsx)(n.code,{children:"main"})," would ",(0,i.jsx)(n.em,{children:"receive"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Inside ",(0,i.jsx)(n.code,{children:"task1"}),", we would just set a timer and wait until it fires. After it fires, we send a signal through the channel, to indicate that 1 second has elapsed."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[embassy_executor::task]\nasync fn task1() {\n    loop {\n        Timer::after_secs(1).await;\n        CHANNEL.send(true).await;\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the ",(0,i.jsx)(n.code,{children:"main"})," function, we need to then wait for the signal, and once it's received, toggle the LED."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// ---- fn main() ----\nloop {\n    let value = CHANNEL.receive().await;\n    match value {\n        true => led.toggle().unwrap(),\n        false => info!("We got something else")\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["The reason we need all of this is because Rust doesn't allow us to mutably borrow more than once. To use a peripheral (say PWM) inside multiple tasks,\nwe would need to either move it inside the task entirely, or use a mutable reference to it. If we have multiple tasks, though, once we move our peripheral variable ",(0,i.jsx)(n.em,{children:"inside"})," the first task,\nwe can't pass it to another task, because the value was ",(0,i.jsx)(n.em,{children:"moved"})," inside that task completely. And if we wanted to pass it as a mutable reference instead, we would quickly realize that Rust\ndoesn't allow multiple mutable references at once, to avoid concurrent modifications. So this is why we need to either declare a global, static ",(0,i.jsx)(n.code,{children:"Mutex"})," that any task can access, to ensure\nthat the value cannot be modified concurrently by two different tasks, or use channels and keep the peripheral inside the ",(0,i.jsx)(n.code,{children:"main"})," function."]}),(0,i.jsxs)(n.p,{children:["To better understand the concepts of ownership and borrowing in Rust, take a look at ",(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html",children:"chapter 4"})," of the Rust Book."]})]}),"\n",(0,i.jsx)(n.h3,{id:"signal",children:(0,i.jsx)(n.code,{children:"Signal"})}),"\n",(0,i.jsxs)(n.p,{children:["This is similar to a ",(0,i.jsx)(n.code,{children:"Channel"})," with a buffer size of 1, except \u201csending\u201d to it (calling ",(0,i.jsx)(n.code,{children:"Signal::signal"}),") when full will overwrite the previous value instead of waiting for the receiver to pop the previous value."]}),"\n",(0,i.jsx)(n.p,{children:"It is useful for sending data between tasks when the receiver only cares about the latest data, and therefore it's fine to \u201close\u201d messages. This is often the case for \u201cstate\u201d updates."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'\nuse embassy_sync::signal::Signal;\n\nstatic SIG: Signal<CriticalSectionRawMutex, ()> = Signal::new();\n\n#[embassy_executor::task]\nasync fn waiter() {\n    SIG.wait().await; // Wait until signaled\n    defmt::info!("Signal received!");\n}\n\n#[embassy_executor::task]\nasync fn trigger() {\n    SIG.signal(()); // Notify the waiting task\n}\n\n\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pubsubchannel",children:(0,i.jsx)(n.code,{children:"PubSubChannel"})}),"\n",(0,i.jsx)(n.p,{children:"This is a type of channel where any published message can be read by all subscribers. A publisher can choose how it sends its message."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"With Pub::publish() the publisher has to wait until there is space in the internal message queue."}),"\n",(0,i.jsx)(n.li,{children:"With Pub::publish_immediate() the publisher doesn't await and instead lets the oldest message in the queue drop if necessary. This will cause any Subscriber that missed the message to receive an error to indicate that it has lagged."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'\nuse embassy_sync::pubsub::PubSubChannel;\n\nstatic PUB: PubSubChannel<CriticalSectionRawMutex, &\'static str, 4, 2> = PubSubChannel::new();\n\n#[embassy_executor::task]\nasync fn publisher() {\n    PUB.publisher().publish("Hello").await;\n}\n\n#[embassy_executor::task]\nasync fn subscriber1() {\n    let mut sub = PUB.subscriber().unwrap();\n    let msg = sub.next_message().await;\n    defmt::info!("Sub 1 got: {}", msg);\n}\n\n#[embassy_executor::task]\nasync fn subscriber2() {\n    let mut sub = PUB.subscriber().unwrap();\n    let msg = sub.next_message().await;\n    defmt::info!("Sub 2 got: {}", msg);\n}\n\n'})}),"\n",(0,i.jsx)(n.h2,{id:"buzzer",children:"Buzzer"}),"\n",(0,i.jsx)(n.p,{children:"A buzzer is a hardware device that emits sound. There are two types of buzzers:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"active buzzer"})," - connected to VCC and GND, with a resistance - emits a constant frequency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"passive buzzer"})," - connected to a GPIO pin and GND, with a resistance - frequency can be controlled through the pin with PWM"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Buzzer",src:t(7744).A+"",width:"327",height:"327"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["To control the buzzer, all you need to do is to set the ",(0,i.jsx)(n.code,{children:"top"})," value of the PWM config to match the frequency you want!"]})}),"\n",(0,i.jsx)(n.h4,{id:"how-to-wire-an-rgb-led",children:"How to wire an RGB LED"}),"\n",(0,i.jsx)(n.p,{children:"The buzzer on the development board is connected to a pin in the J9 block."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"board_buzzer",src:t(16063).A+"",width:"331",height:"480"})}),"\n",(0,i.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Use two separate tasks to make the RED LED and BLUE LED blink 1 time per second. Instead of using ",(0,i.jsx)(n.code,{children:"Timer::after_millis(time_interval).await"})," use ",(0,i.jsx)(n.em,{children:"busy waiting"})," by starting a timer using ",(0,i.jsx)(n.code,{children:"Instant::now();"})," and checking the elapsed time in a ",(0,i.jsx)(n.code,{children:"while"})," loop using"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"while start_time.elapsed().as_millis() < time_interval {}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You should notice that one of the tasks is not running. Why? (",(0,i.jsx)(n.strong,{children:"1p"}),")"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Use a different task instance for each LED. You can spawn multiple instances of the same task, however you need to specify the pool size with ",(0,i.jsx)(n.code,{children:"#[embassy_executor::task(pool_size = 2)]"}),". Take a look at ",(0,i.jsx)(n.a,{href:"https://docs.embassy.dev/embassy-executor/git/std/index.html#task-arena",children:"task-arena"})," for more info.\nUse ",(0,i.jsx)(n.a,{href:"https://docs.embassy.dev/embassy-rp/git/rp2040/gpio/struct.AnyPin.html",children:(0,i.jsx)(n.code,{children:"AnyPin"})})," and blinking frequency parameters for the task."]})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["Fix the usage of busy waiting from exercise 1 and make the 4 LEDs (YELLOW, RED, GREEN, BLUE) blink at different frequencies. (",(0,i.jsx)(n.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Blink:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"LED"}),(0,i.jsx)(n.th,{children:"frequency"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"YELLOW"}),(0,i.jsx)(n.td,{children:"3 Hz"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"RED"}),(0,i.jsx)(n.td,{children:"4 Hz"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"GREEN"}),(0,i.jsx)(n.td,{children:"5 Hz"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"BLUE"}),(0,i.jsx)(n.td,{children:"1 Hz"})]})]})]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"1 Hz means once per second."})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Write a firmware that changes the RED LED's intensity, using switch ",(0,i.jsx)(n.strong,{children:"SW_4"})," and switch ",(0,i.jsx)(n.strong,{children:"SW_5"}),". Switch ",(0,i.jsx)(n.strong,{children:"SW_4"})," will increase the intensity, and switch ",(0,i.jsx)(n.strong,{children:"SW_5"})," will decrease it. You will implement this in three ways: (",(0,i.jsx)(n.strong,{children:"3p"}),")"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Use three tasks : one task will be the ",(0,i.jsx)(n.code,{children:"main"})," to control the LED and another two tasks for each button (one for switch ",(0,i.jsx)(n.strong,{children:"SW_4"}),", one for switch ",(0,i.jsx)(n.strong,{children:"SW_5"}),"). Use a ",(0,i.jsx)(n.a,{href:"#channel",children:(0,i.jsx)(n.code,{children:"Channel"})})," to send commands from each button task to the main task."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Use an ",(0,i.jsx)(n.code,{children:"enum"})," to define the LED Intensity change command for point i."]})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["Use a single task (",(0,i.jsx)(n.code,{children:"main"}),"). Use ",(0,i.jsx)(n.a,{href:"#select",children:(0,i.jsx)(n.code,{children:"select"})})," to check which of the buttons were pressed and change the LED intensity accordingly."]}),"\n",(0,i.jsxs)(n.li,{children:["Use two tasks: one taks will be the ",(0,i.jsx)(n.code,{children:"main"})," to control the LED and another one for both buttons. Use a ",(0,i.jsx)(n.a,{href:"#signal",children:(0,i.jsx)(n.code,{children:"Signal"})})," channel to transmit from the buttons task, the new value of the intensity which the LED will be set to. The ",(0,i.jsx)(n.code,{children:"main"})," will wait for a new value on the ",(0,i.jsx)(n.code,{children:"Signal"})," channel and change the intensity accordingly."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Instead of sending commands over the channel like you did at point i, send the intensity value as a number."})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Simulates a traffic light using the GREEN, YELLOW and RED LEDs on the board. Normally the traffic light goes from one state based on the time elapsed (Green -> 5s , Yellow Blink (4 times) -> 1s , Red -> 2s ).\nHowever if the switch ",(0,i.jsx)(n.strong,{children:"SW4"})," is pressed the state of traffic light changes immediately as shown in the diagram bellow.(",(0,i.jsx)(n.strong,{children:"2p"}),")"]}),"\n",(0,i.jsx)(n.mermaid,{value:"flowchart LR\n    green(GREEN) -- Button pressed --\x3e yellow(Yellow)\n    green(GREEN) -- 5s --\x3e yellow(Yellow)\n\n    \n    yellow(YELLOW - Blink 4 times/second) -- Button pressed --\x3e red(RED)\n\n    yellow(YELLOW - Blink 4 times/second) -- 1s --\x3e red(RED)\n\n    red(RED) -- Button pressed --\x3e red(RED)\n    red(RED) -- 2s --\x3e green(GREEN)\n\n    classDef red fill:#ff0000,stroke:#000000,color: #ffffff\n    classDef yellow fill:#efa200,stroke:#000000\n    classDef green fill:#00ce54,stroke:#000000\n\n    class red red\n    class yellow yellow\n    class green green"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["For this exercise you only need one task. Define an ",(0,i.jsx)(n.code,{children:"enum"})," to save the traffic light state (",(0,i.jsx)(n.code,{children:"Green"}),", ",(0,i.jsx)(n.code,{children:"Yellow"}),",",(0,i.jsx)(n.code,{children:"Red"}),"). Use ",(0,i.jsx)(n.code,{children:"match"})," to check the current state of the traffic light. Then you need to wait for two futures, since the traffic light changes its color either because some time has elapsed or because the button was pressed. Use ",(0,i.jsx)(n.code,{children:"select"})," to check which future completes first (",(0,i.jsx)(n.code,{children:"Timer"})," or button press)."]})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Continue exercise 4: this time, instead of using only the switch ",(0,i.jsx)(n.strong,{children:"SW4"})," to change the state of traffic light, we will use the switches ",(0,i.jsx)(n.strong,{children:"SW4"})," and ",(0,i.jsx)(n.strong,{children:"SW7"})," pressed consecutively to trigger a state change of the traffic light. Use ",(0,i.jsx)(n.code,{children:"join"})," to check that both switches were pressed. (",(0,i.jsx)(n.strong,{children:"1p"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsx)(n.p,{children:"The switches don't need to be pressed at the same time, but one after the other. The order does not matter."}),(0,i.jsx)(n.p,{children:"The traffic light transitions between states either based on the elapsed time or through pressing the switches as described above."})]}),"\n",(0,i.jsxs)(n.ol,{start:"6",children:["\n",(0,i.jsxs)(n.li,{children:["Continue exercise 5:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["add a new task to control the buzzer. The buzzer should make a continuous low frequency (200Hz) sound while the traffic light is green or yellow and should start beeping (at 400Hz) on and off while the traffic light is red (Use the ",(0,i.jsx)(n.a,{href:"./03#calculating-the-top-value",children:"formula from Lab03"})," to calculate the frequency) . (",(0,i.jsx)(n.strong,{children:"1p"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["add a new task for a servo motor. Set the motor position at 180\xb0 when the light is green, 90\xb0 the light is yellow, and 0\xb0 if its red. (",(0,i.jsx)(n.strong,{children:"1p"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Use a ",(0,i.jsx)(n.code,{children:"PubSubChannel"})," to transmit the state of the traffic light from the LEDs task to both the buzzer and the servo motor tasks."]})}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},16063:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/board_buzzer-39836b6dab395375e4ad9ab5270d906c.png"},7744:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/buzzer-d17a0a1976fed5a42c3c7ffa0edb36f2.png"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(96540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);